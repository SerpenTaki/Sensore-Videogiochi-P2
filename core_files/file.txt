#ifndef CONTENTVISITOR_H
#define CONTENTVISITOR_H

#include"QT_files/headers/viewlib.h"

class ContentVisitor : public Visitor {
private:
    QWidget* dispWidget;
public:
    ContentVisitor();
    ~ContentVisitor();

    void visitFisico(fisico* f) override;
    void visitMagico(magico* m) override;
    void visitSacro(sacro* s) override;
    
    QWidget* returnQWidget();
};

#endif
#ifndef FISICO_H
#define FISICO_H

#include "sensoreDanno.h"
#include "visitor.h"

class fisico : virtual public sensoreDanno {
private:
  int affilatura;
public:
  // per implementazione grafica
  fisico(string n, double d, int nT, int aff);

  int getAffilatura() const;

  double getHit() override;
  double calcolaDanno() override;

  void accept(Visitor* v) override;
};

#endif
#ifndef MAGICO_H
#define MAGICO_H

#include "sensoreDanno.h"

class magico : virtual public sensoreDanno {
private:
  int lvMagia; // dall' 1 al 5
  bool isInStatus;
public:
  magico(string n, double d, int nT, int lvM, bool isInSta);


  int getLvMagia() const;
  bool checkCondition() const;

  string setStatus();

  double calcolaDanno() override;
  double getHit() override;

  void accept(Visitor* v) override;
};

#endif
#ifndef SACRO_H
#define SACRO_H

#include "sensoreDanno.h"

class sacro : public sensoreDanno {
private:
  int lvFede;     /* 0 , 1, 2 */
  int limitbreak; // quando il parametro raggiunge 10 hai vinto la partita,
  vector<int> limitBar; // mostra nuovo grafico del limit break
  enum { fedeBassa, fedeMedia, fedeAlta };
public:
  sacro(string n, double d, int nT, int lvFede);

  int getLvFede() const;
  int getlimitBreak() const;

  double getHit() override;
  double calcolaDanno() override;
  
  bool checkLimit();
  void updateLimitbreak();
  vector<int> getValoriLimitBar();

  void accept(Visitor* v) override;
  
};

#endif
#ifndef SENSOREDANNO_H
#define SENSOREDANNO_H

// #include <iostream>
#include <string>
#include <vector>
#include <iostream>
#include <random>
#include"visitor.h"

using std::string;
using std::vector;
using std::cout;
using std::endl;

class sensoreDanno {
private:
  string nome;
  double danno;
  int probHit;  // random
  int probCrit; // random
  int randN;
  int nTurni;
public:
  vector<int> attacchiPerTurno;
  sensoreDanno(string n, double d, int nT);
  virtual ~sensoreDanno();

  virtual vector<double> getValoriGrafico(int nTurni) final; // metodo per il grafico
  // Metodi getter
  double getDanno() const;
  int getProbHit();
  int getProbCrit();
  int getRand();
  string getNome() const;
  int getNTurni() const;
  //Metodi setter per modifica sensore
  vector<int> getAttacchiPerTurno() const;
  
  // metodi virtuali puri
  virtual double calcolaDanno()=0;
  virtual double getHit() =0;

  virtual void accept(Visitor* v) = 0;
};

#endif
#ifndef VISITOR_H
#define VISITOR_H

class fisico;
class magico;
class sacro;

class Visitor {
public:
    virtual void visitFisico(fisico* f) = 0;
    virtual void visitMagico(magico* m) = 0;
    virtual void visitSacro(sacro* s) = 0;
};

#endif
#include"headers/contentvisitor.h"

ContentVisitor::ContentVisitor() {}

ContentVisitor::~ContentVisitor() {
    delete dispWidget;
}

void ContentVisitor::visitFisico(fisico* f){
    dispWidget = new QLabel("Sensore Fisico:\nNome:" + QString::fromStdString(f->getNome()) +
     "\nDannoBase:" + QString::number(f->getDanno()) +
     "\nNumero di Turni:" + QString::number(f->getNTurni()) +
     "\nAttacchi per Turno:" + QString::number(f->attacchiPerTurno.size()) + 
     "\nAffilatura:" + QString::number(f->getAffilatura()) + "%");
}

void ContentVisitor::visitMagico(magico* m){
    dispWidget = new QLabel("Sensore Magico:\nNome:" + QString::fromStdString(m->getNome()) +
     "\nDannoBase:" + QString::number(m->getDanno()) +
     "\nNumero di Turni:" + QString::number(m->getNTurni()) +
     "\nAttacchi per Turno:" + QString::number(m->attacchiPerTurno.size()) + 
     "\nLivello Magia:" + QString::number(m->getLvMagia()) +
     "\nCondizione:" + (m->checkCondition() ? "Si" : "No"));
}

void ContentVisitor::visitSacro(sacro* s){
    dispWidget = new QLabel("Sensore Sacro:\nNome:" + QString::fromStdString(s->getNome()) +
     "\nDannoBase:" + QString::number(s->getDanno()) +
     "\nNumero di Turni:" + QString::number(s->getNTurni()) +
     "\nAttacchi per Turno:" + QString::number(s->attacchiPerTurno.size()) + 
     "\nLivello Fede:" + QString::number(s->getLvFede()) +
     "\nValore Limit:" + QString::number(s->getlimitBreak()));
}

QWidget* ContentVisitor::returnQWidget() {
    return dispWidget;
}#include "headers/fisico.h"

fisico::fisico(string n, double d, int nT, int aff): sensoreDanno(n, d, nT), affilatura(aff) {
  cout << "Oggetto fisico Creato" << endl;
}

int fisico::getAffilatura() const { return affilatura; }

double fisico::getHit() { /*si collega all'interfaccia grafica*/
  if (getProbHit() > 30) {
    return this->calcolaDanno();
  }
  return 0.0;
}

double fisico::calcolaDanno() { // assestante
  double nDanni = getDanno();
  nDanni = nDanni * affilatura / 10;
  if (getProbCrit() > 75) {
    nDanni = (nDanni * 30) / 100;
    return nDanni;
  } else
    return nDanni;
}

void fisico::accept(Visitor* v) {
  v->visitFisico(this);
}#include "headers/magico.h"

magico::magico(string n, double d, int nT, int lvM, bool isInSta): sensoreDanno(n, d, nT), lvMagia(lvM), isInStatus(isInSta) {
  std::cout << "Oggetto magico creato" << std::endl;
}

int magico::getLvMagia() const { return lvMagia; }

bool magico::checkCondition() const { return isInStatus; }

double magico::getHit() {
  if (getProbHit() > 45) {
    return calcolaDanno();
  }
  return 0.0;
}

double magico::calcolaDanno() {
  double nDanni = getDanno();
  nDanni = nDanni + ((getLvMagia() / 2) * 2);
  if (checkCondition()) {
    nDanni = nDanni + nDanni * 0.3;
    if (getProbCrit() > 85) {
      nDanni = (nDanni * 20) / 100;
    }
    return nDanni;
  }
  setStatus();
  return nDanni;
}

string magico::setStatus() {
  if (getRand() > 70) {
    //checkCondition() = true; //da sistemare
    return "incantato";
  }
  else
    return "nope";
}

void magico::accept(Visitor* v){
  v->visitMagico(this);
}
#include "headers/sacro.h"

sacro::sacro(string n, double d, int nT, int lvFede): sensoreDanno(n, d, nT), lvFede(lvFede){
  std::cout << "Oggetto sacro Creato" << std::endl;
}



int sacro::getLvFede() const { return lvFede; }
int sacro::getlimitBreak() const { return limitbreak; }

bool sacro::checkLimit() { /*Gestito dalla UI mi fa vincere magari pop-up*/
  if (limitbreak < 100)
    return false;
  else
    return true;
}

double sacro::getHit() { /*si collega all'interfaccia grafica*/
  if (getProbHit() > 80) {
    return this->calcolaDanno();
  }
  return 0.0;
}

double sacro::calcolaDanno() {
  double nDanni = getDanno();
  if (lvFede == fedeBassa) {
    nDanni = nDanni * 20 / 10;
  } else if (lvFede == fedeMedia) {
    nDanni = nDanni * 40 / 10;
  } else {
    nDanni = nDanni * 65 / 10;
  }
  if (getProbCrit() > 40) {
    nDanni = (nDanni * 15) / 100;
  }
  updateLimitbreak();
  return nDanni;
}

void sacro::updateLimitbreak() {
    /* Questo metodo mi calcola un numero random da 1 a 10 e mi restituisce il
     * valore aggiornato di limit */
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(1, 10);
    int randomValue = dis(gen);
    limitbreak += randomValue;
}


vector<int> sacro::getValoriLimitBar() {
  vector<int> result;
  for (auto i = limitBar.begin(); i != limitBar.end(); i++) {
    int limitPerTurno = *i + limitbreak;
    result.push_back(limitPerTurno);
  }
  return result;
}

void sacro::accept(Visitor* v){
  v->visitSacro(this);
}#include "headers/sensoreDanno.h"
#include <random>

sensoreDanno::sensoreDanno(string n, double d, int nT): nome(n), danno(d), nTurni(nT) {
  cout << "Oggetto Creato" << endl;
}

sensoreDanno::~sensoreDanno() {cout << "Distrutto porcamadonna" << endl;} //ho notato che elimina sensore non distrugge il sensore alla fine

int sensoreDanno::getNTurni() const{
  return nTurni;
}

double sensoreDanno::getDanno() const { 
  return danno;
}

int sensoreDanno::getProbCrit(){
  /*random*/
  probCrit = getRand(); 
  return probCrit;
}

int sensoreDanno::getProbHit(){
  /*random*/
  probHit = getRand();
  return probHit;
}

std::string sensoreDanno::getNome() const {
  return nome;
}

int sensoreDanno::getRand() {
  std::random_device rd;
  std::mt19937 gen(rd());
  std::uniform_int_distribution<> dis(1, 100);
  randN = dis(gen);
  return randN;
}

vector<int> sensoreDanno::getAttacchiPerTurno() const{
  return attacchiPerTurno;
}

vector<double> sensoreDanno::getValoriGrafico(int nTurni) {
  vector<double> result;
  for(int j=0; j<= nTurni; j++){
    double dannoPerTurno = 0;
    for (auto i = attacchiPerTurno.begin(); i != attacchiPerTurno.end(); i++) {
      dannoPerTurno = *i * getHit();
    }
    result.push_back(dannoPerTurno);
  }
  return result;
} // Questa non si ovverrida da nessuna parte
